# -*- coding: utf-8 -*-
"""Test500.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12NodqrRayca5MCJT8u1WeagILwSO-Y6N

# Step 3: Optimize the different alternatives

**Jorge Leonardo Lemus**

`Cod 220518936`

## Portfolio optimization using efficient frontier

This technique look forward to create a portfolio of assets getting a maximum return and minimum risk.

In the Modern Portfolio Theory (MPT), it is use a mean-variance analysis aproach. This type of analysis was formulated by H. Markowitz.

This model encourages diversification in assets, The combination of different assets with low correlation can give us a portfolio with low variance on returns. 

In a plot we will be able to see in the Y-axis the returns and in the X-axis the volatility. the ideal portfolio lies in the frontier, for a given risk level, we will be able to find the better potential return.
"""

# We installed the neccesary libraries to run the program

import yfinance as yf
import numpy as np 
import pandas as pd
from pandas_datareader import data as pdr
import matplotlib.pyplot as plt
yf.pdr_override() 
import datetime as dt 
from dateutil.relativedelta import relativedelta

"""##1 Add the list of assets 

We add the list of assets we are interested in optimising using the past price returns.  
"""

#Get tiickers symbols the DJI
table = pd.read_html('https://www.investopedia.com/terms/d/djia.asp')[0]

table.columns

#tick = table[('Dow Jones Industrial Average Components',    'Symbol')].tolist()
tick =['AXP', 'AAPL', 'CVX', 'HD', 'MSFT', 'UNH'] #, 'JNJ', 'MCD', 'MRK', 'NKE','PG', 'CRM', 'TRV', 'V', 'WMT']

#get prices for the dji for the last year
start = dt.datetime(2021,3,31)
#start1 = dt.datetime(2021,3,21)
end = dt.datetime(2022,3,31)

#load the data in one DataFrame
ind_data = pd.DataFrame()
for t in tick:
  ind_data[t] = pdr.DataReader(t,data_source='yahoo', start= start, end =end )['Adj Close']
print (ind_data.head())

#Charge the style for the plot
plt.style.use('fivethirtyeight')

ind_data.head()

"""## 2 Calculate the variance and Covariance

With these information we are able to identify how volatile the investment will be and how the returns can fluctuate.
"""

#Covariance and Correlation matrix
cov_matrix = ind_data.pct_change().apply(lambda x: np.log(1+x)).cov()
cov_matrix
#Covariance measures the directional relationship between the returns on two assets.

#The correlation matrix indicates in which way one asset moves given the change of the other asset.
#the correlation number is between -1 and 1,
# When the number is close to 1 the relationship is positive strong.
# When the number is close to -1 the relationship is negative strong.  
# When the number is close to 0 the relationship is null. 
corr_matrix = ind_data.pct_change().apply(lambda x: np.log(1+x)).corr()
corr_matrix

"""## 3 Creation of the Optimal portfolio

We assign a weight of each asset, they must add up to 1.
For this case we split in equal parts our assets.
"""

a=[]
i=0
for i in ind_data.columns:
  i = + 1 
  b = i/(len(ind_data.columns))
  a.append(b)
print (a)

#Create a dictionary with the weight of the portfolio and the name of  the asset
w = dict(zip(ind_data.columns, a))
print(w)

port_var = cov_matrix.mul(w, axis=0).mul(w, axis=1).sum().sum()
port_var

"""##Portfolio expected returns"""

# monthly returns for individual companies
ind_er = ind_data.resample('m').last().pct_change().mean()
ind_er

"""The sum of all return individuals assets is the total performance of our portfolio."""

#Portfolio returns
port_er = (a*ind_er).sum()
port_er

# Volatility is given by the monthly standard deviation. We multiply by 24 because there are 24 trading days/month.
mtl_sd = ind_data.pct_change().apply(lambda x: np.log(1+x)).std().apply(lambda x: x*np.sqrt(24))
mtl_sd

"""We gather the information in one Dataframe to be use after."""

# Creating a table for visualising returns and volatility of assets
assets = pd.concat([ind_er, mtl_sd], axis=1) 
assets.columns = ['Returns', 'Volatility']
assets

#We create a loop to check all the possible combinations. 

#run loop 
p_ret = [] # Define an empty array for portfolio returns
p_vol = [] # Define an empty array for portfolio volatility
p_weights = [] # Define an empty array for asset weights


num_assets = len(ind_data.columns)
num_portfolios = 10000
np.random.seed(99)

for portfolio in range(num_portfolios):
  weights = np.random.random(num_assets)
  weights = weights/np.sum(weights)
  p_weights.append(weights)
  returns = np.dot(weights, ind_er) # Returns are the product of individual expected returns of asset and its weights

  p_ret.append(returns)
  var = cov_matrix.mul(weights, axis=0).mul(weights, axis=1).sum().sum() #Portfolio Variance
  sd = np.sqrt(var)#hour??? standard deviation
  ann_sd = sd*np.sqrt(24) # monthly standard deviation = volatility
  p_vol.append(ann_sd)

"""We gather all the results for the different portfolio combinations in the variable data"""

data = {'Returns':p_ret, 'Volatility':p_vol}

for counter, symbol in enumerate(ind_data.columns.tolist()):
    #print(counter, symbol)
    data[symbol+' weight'] = [w[counter] for w in p_weights]

"""We create a dataframe with the different returns, volatility and weights for each portfolio combination.


"""

portfolios  = pd.DataFrame(data)
portfolios.head() # Dataframe of the 10000 portfolios created

"""We plot the different combinations """

portfolios.plot.scatter(x='Volatility', y='Returns', marker='o', s=10, alpha=0.3, grid=True, figsize=[10,10])
plt.title('Combination different portfolios')

portfolios.Returns.mean()

min_vol_port = portfolios.iloc[portfolios['Volatility'].idxmin()]
#idxmin() gives us the minimum value in the column specified.                               
min_vol_port

"""The red star denotes the most efficient portfolio with minimum volatility. But not neccesary the most profitable scenario """

# plotting the minimum volatility portfolio
plt.subplots(figsize=[10,10])
plt.scatter(portfolios['Volatility'], portfolios['Returns'],marker='o', s=10, alpha=0.3)
plt.scatter(min_vol_port[1], min_vol_port[0], color='r', marker='*', s=500)

"""Sharpe Ratio
We take as a risk-free rate 1%
"""

# Finding the optimal portfolio
rf = 0.001 # risk factor
optimal_risky_port = portfolios.iloc[((portfolios['Returns']-rf)/portfolios['Volatility']).idxmax()]
optimal_risky_port

# Plotting optimal portfolio
plt.subplots(figsize=(10, 10))
plt.scatter(portfolios['Volatility'], portfolios['Returns'],marker='o', s=10, alpha=0.3)
plt.scatter(min_vol_port[1], min_vol_port[0], color='r', marker='*', s=500)
plt.scatter(optimal_risky_port[1], optimal_risky_port[0], color='g', marker='*', s=500)

"""At the green star investor are getting the most reward for unit of risk for this portfolio
sharpe ration under 0 is better keep the risk free asset 
sharpe ratio between 0 and 1 indicate that maybe the investment is better than the risk free asset
Sharpe ratio over 1 means the investment asset is above average
"""