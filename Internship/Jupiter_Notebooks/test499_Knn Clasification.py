# -*- coding: utf-8 -*-
"""Test501.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QY3yqeDx1S-bhvVzsWjWeLMgv2dXuNtf

# Step 3: Classify different alternatives

**Jorge Leonardo Lemus**

`Cod 220518936`
"""

# We installed the neccesary libraries to run the program
import yfinance as yf
import numpy as np 
import pandas as pd
from pandas_datareader import data as pdr
import matplotlib.pyplot as plt
yf.pdr_override() 
import datetime as dt 
from dateutil.relativedelta import relativedelta
from sklearn.cluster import KMeans
plt.style.use('fivethirtyeight')

#Get tickers symbols the DJI
#table = pd.read_html('https://www.investopedia.com/terms/d/djia.asp')[0]
#Get tickers symbols S&P 500
table = pd.read_html('https://en.wikipedia.org/wiki/List_of_S%26P_500_companies')[0]

table.columns

#tick = table[('Dow Jones Industrial Average Components',    'Symbol')].tolist() # for Dow jones
tick = table['Symbol'].tolist()

#get prices for the dji for the last year
start = dt.datetime(2021,3,31)
#start1 = dt.datetime(2021,3,21)
end = dt.datetime(2022,3,31)

#load the data in one DataFrame
ind_data = pd.DataFrame()
for t in tick:
  ind_data[t] = pdr.DataReader(t,data_source='yahoo', start= start, end =end )['Adj Close']
print (ind_data.head())


#calculate the annual returns and variance
daily_returns = ind_data.pct_change()
annual_mean_returns = daily_returns.mean()*251
annual_returns_variance = daily_returns.var()* 251

#create a new dataframe
df = pd.DataFrame(ind_data.columns, columns = ['Stock Symbols'])
df['Variances'] = annual_returns_variance.values
df['Returns'] = annual_mean_returns.values
#show the data
df.head(3)



#check missing data 
if df.isna().values.any().sum()> 0:
  check_missing = df.isnull()
  for column in check_missing.columns.values.tolist():
    print (column)
  print(check_missing[column].value_counts())
  df.dropna(axis = 0, inplace= True)

#use the elbow method to determine the number of clusters
#to use to group the stocks 
#Get and store the annual returns and annual variances
X= df[['Returns', 'Variances']].values
inertia_list = []
for k in range(2,25):
  #create and train the model
  kmeans = KMeans(n_clusters = k,random_state=99)
  kmeans.fit(X)
  inertia_list.append(kmeans.inertia_)

#Plot the data
plt.plot(range(2,25), inertia_list)
plt.title('Elbow Curve')
plt.xlabel('Number of Clusters')
plt.ylabel('Inertia or Sum Squared Error(SSE)')
plt.show()

#Get and Show the labels / groups
kmeans = KMeans(n_clusters = 5).fit(X)
labels = kmeans.labels_
labels

c = []
for i in range(0,5):
  a=[]
  a = df.loc[(df['Cluster_labels'] == i)].sort_values(by="Returns",ascending=False).index[0]
  c.append(a)
dfa= df.loc[c, :]
dfa = dfa.sort_values(by="Returns",ascending=False)
dfa['Cluster_legend']= ['Really good Positive Returns','Medium Returns', 'Acceptable Positive Returns','Close to zero Returns','Negative Returns']

#The Dataframe df3 belongs to the best perfomarnce asset in each group
dfa

legend = dfa[['Cluster_labels','Cluster_legend']]
leg = legend.set_index('Cluster_labels')
test = leg.to_dict()

leg

'''Cluster_legend = []
for row in df['Cluster_labels']:
  if row == 1.0 :    Cluster_legend.append('Really good Positive Returns')
  elif row== 2.0:   Cluster_legend.append('Negative Returns')
  elif row == 3.0:  Cluster_legend.append('Medium Returns')
  elif row == 4.0:  Cluster_legend.append('Close to zero Returns')
  else:           Cluster_legend.append('Acceptable Positive Returns')

#leg.index[:] == df2[df2['Cluster_labels']==0]['Cluster_labels']

"""realmente cerca pero se necesita relacionar con la organizacion anteriro"""

df['Cluster_legend']= Cluster_legend
df.head(2)

f=[]
#for labels,legend in zip(df2['Cluster_labels'], legend['Cluster_legend']):
if df2[df2['Cluster_legend']] == 0:
  df2 = df2['Cluster_Legend'] = legend['Cluster_legend']
  df2.concat(f)

df2[df2['Cluster_labels'] == 0]

df[df['Cluster_labels']==0].sort_values(by="Returns",ascending=False)

legend = ['Close to zero returns','Acceptable Positive Returns','Medium Returns','Really good Positive Returns','Negative Returns' ]
if df2[df2['Cluster_labels']==0]:
  df2['Cluster_Legend'] = legend[0]
elif df2[df2['Cluster_labels']==1]:
  df2['Cluster_Legend'] = legend[1]
elif df2[df2['Cluster_labels']==2]:
  df2['Cluster_Legend'] = legend[2]
elif df2[df2['Cluster_labels']==3]:
    df2['Cluster_Legend'] = legend[3]
else:
  df2['Cluster_Legend'] = legend[4]
df2.head(3)

# create a list of our conditions
conditions = [
    (df[df['Cluster_labels']==0]),
    (df[df['Cluster_labels']==1]),
    (df[df['Cluster_labels']==2]),
    (df[df['Cluster_labels']==3]),
    (df[df['Cluster_labels']==4])
    ]

# create a list of the values we want to assign for each condition
values = ['Close to zero returns', 
          'Acceptable Positive Returns', 
          'Medium Returns', 
          'Really good Positive Returns',
          'Negative Returns' ]


# create a new column and use np.select to assign values to it using our lists as arguments
df2['Cluster_legend'] = np.select(conditions, values)



legend'''

#Plot and show the different clusters
plt.scatter(X[:,[0]],X[:,[1]], c = labels, cmap = 'rainbow')
plt.title('K-means plot')
plt.xlabel('Returns')
plt.ylabel('Variances')
plt.legend(legend, loc='upper right')
plt.show

#Create a function to build a simple diversed portfolio with the two best performance of each group
from functools import reduce
symbol=[]
def diversed_port():
  for i in range (0,5):
    a = df[df['Cluster_labels']==i].sort_values(by="Returns",ascending=False)
    a = a[a['Cluster_labels']==i]['Stock Symbols'][:2].tolist() #.head(1)
    symbol.append(a)
    single_list = reduce(lambda x,y: x+y, symbol)
  print(single_list)

print('This list belong to the diversed portfolio:')
diversed_port()

from functools import reduce
symbol=[]
#Create a function to build a simple diversed portfolio but take the result into a list
def diversed_var_port1():
  for i in range (0,5):
    b = df[df['Cluster_labels']==i].sort_values(by="Variances",ascending=True)
    b = b[b['Cluster_labels']==i]['Stock Symbols'][:2].tolist()
    symbol.append(b)
    single_list = reduce(lambda x,y: x+y, symbol)
  print(single_list)

diversed_var_port1()

print('This two assets have the best performance on our model')
a =df[df['Cluster_labels']==0].sort_values(by="Returns",ascending=False)
a[a['Cluster_labels']==0]['Stock Symbols'][:2].tolist()

#diversed_port1()

df[df['Cluster_labels']==4].sort_values(by="Returns",ascending=False)

print('This list of assets belong to the best cluster performance in the Kmeans model:')
df[df['Cluster_labels']==0]['Stock Symbols'].tolist()

df[df['Cluster_labels']==0].sort_values(by="Returns",ascending=False)
df[df['Cluster_labels']==1].sort_values(by="Returns",ascending=False)